Time responses
==============

LTI response functions
----------------------

A number of functions are available for computing the output (and
state) response of an LTI systems:

.. autosummary::

   initial_response
   step_response
   impulse_response
   forced_response

Each of these functions returns a :class:`TimeResponseData` object
that contains the data for the time response (described in more detail
in the next section).

The :func:`forced_response` system is the most general and allows by
the zero initial state response to be simulated as well as the
response from a non-zero initial condition.

For linear time invariant (LTI) systems, the :func:`impulse_response`,
:func:`initial_response`, and :func:`step_response` functions will
automatically compute the time vector based on the poles and zeros of
the system.  If a list of systems is passed, a common time vector will be
computed and a list of responses will be returned in the form of a
:class:`TimeResponseList` object.  The :func:`forced_response` function can
also take a list of systems, to which a single common input is applied.
The :class:`TimeResponseList` object has a `plot()` method that will plot
each of the responses in turn, using a sequence of different colors with
appropriate titles and legends.

In addition the :func:`input_output_response` function, which handles
simulation of nonlinear systems and interconnected systems, can be
used.  For an LTI system, results are generally more accurate using
the LTI simulation functions above.  The :func:`input_output_response`
function is described in more detail in the :ref:`iosys-module` section.

.. currentmodule:: control
.. _time-series-convention:

Time series data
----------------
A variety of functions in the library return time series data: sequences of
values that change over time.  A common set of conventions is used for
returning such data: columns represent different points in time, rows are
different components (e.g., inputs, outputs or states).  For return
arguments, an array of times is given as the first returned argument,
followed by one or more arrays of variable values.  This convention is used
throughout the library, for example in the functions
:func:`forced_response`, :func:`step_response`, :func:`impulse_response`,
and :func:`initial_response`.

.. note::
    The convention used by python-control is different from the convention
    used in the `scipy.signal
    <https://docs.scipy.org/doc/scipy/reference/signal.html>`_ library. In
    Scipy's convention the meaning of rows and columns is interchanged.
    Thus, all 2D values must be transposed when they are used with functions
    from `scipy.signal`_.

The time vector is a 1D array with shape (n, )::

      T = [t1,     t2,     t3,     ..., tn    ]

Input, state, and output all follow the same convention. Columns are different
points in time, rows are different components::

      U = [[u1(t1), u1(t2), u1(t3), ..., u1(tn)]
           [u2(t1), u2(t2), u2(t3), ..., u2(tn)]
           ...
           ...
           [ui(t1), ui(t2), ui(t3), ..., ui(tn)]]

(and similarly for `X`, `Y`).  So, `U[:, 2]` is the system's input at the
third point in time; and `U[1]` or `U[1, :]` is the sequence of values for
the system's second input.

When there is only one row, a 1D object is accepted or returned, which adds
convenience for SISO systems:

The initial conditions are either 1D, or 2D with shape (j, 1)::

     X0 = [[x1]
           [x2]
           ...
           ...
           [xj]]

Functions that return time responses (e.g., :func:`forced_response`,
:func:`impulse_response`, :func:`input_output_response`,
:func:`initial_response`, and :func:`step_response`) return a
:class:`TimeResponseData` object that contains the data for the time
response.  These data can be accessed via the
:attr:`~TimeResponseData.time`, :attr:`~TimeResponseData.outputs`,
:attr:`~TimeResponseData.states` and :attr:`~TimeResponseData.inputs`
properties::

    sys = ct.rss(4, 1, 1)
    response = ct.step_response(sys)
    plt.plot(response.time, response.outputs)

The dimensions of the response properties depend on the function being
called and whether the system is SISO or MIMO.  In addition, some time
response function can return multiple "traces" (input/output pairs),
such as the :func:`step_response` function applied to a MIMO system,
which will compute the step response for each input/output pair.  See
:class:`TimeResponseData` for more details.

The input, output, and state elements of the response can be accessed using
signal names in place of integer offsets::

    plt.plot(response. time, response.states['x[1]']

For multi-trace systems generated by :func:`step_response` and
:func:`impulse_response`, the input name used to generate the trace can be
used to access the appropriate input output pair::

    plt.plot(response.time, response.outputs['y[0]', 'u[1]'])

The time response functions can also be assigned to a tuple, which extracts
the time and output (and optionally the state, if the `return_x` keyword is
used).  This allows simple commands for plotting::

    t, y = ct.step_response(sys)
    plot(t, y)

The output of a MIMO LTI system can be plotted like this::

    t, y = ct.forced_response(sys, t, u)
    plot(t, y[0], label='y_0')
    plot(t, y[1], label='y_1')

The convention also works well with the state space form of linear
systems. If `D` is the feedthrough matrix (2D array) of a linear system,
and `U` is its input (array), then the feedthrough part of the system's
response, can be computed like this::

    ft = D @ U

Finally, the `to_pandas()` function can be used to create a pandas dataframe::

    df = response.to_pandas()

The column labels for the data frame are `time` and the labels for the input,
output, and state signals (`u[i]`, `y[i]`, and `x[i]` by default, but these
can be changed using the `inputs`, `outputs`, and `states` keywords when
constructing the system, as described in :func:`ss`, :func:`tf`, and other
system creation function.  Note that when exporting to pandas, "rows" in the
data frame correspond to time and "cols" (DataSeries) correspond to signals.

Input/output response
---------------------

